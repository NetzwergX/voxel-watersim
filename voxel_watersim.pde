
// Import gifAnimation to export the sketch as gifs
import gifAnimation.*;
GifMaker gif;

// N: determines the grid size (N² x N²)
// cw: cube width
// terrainNoise, hueNoise, saturationNoise: noise scales
// Increase terrainNoise to generate more rugged terrains
// Increase hueNoise, saturationNoise accordingly to generate more rugged color landscapes
int N;
float cw;
float terrainNoise,hueNoise,saturationNoise;

// terrain: earth level at each (i,j) coordinate
int[][] terrain;

// water, energy: water levels and kinetic energy levels
float[][] water;
float[][] energy;

// t: simulation time time
float t = 0;

void setup()
{
  // Initialize screen dimensions and 3D mode
  size(400,400,P3D);
  
  // We will work in the hue/saturation/brightness color space
  colorMode(HSB);
  
  // Initialize parameters
  N = 50;
  cw = width/N;
  terrainNoise = 5;
  hueNoise = 3;
  saturationNoise = 3;
  
  // Initialize terrain
  init_terrain();
  
  // Initialize water levels and kinetic energy levels
  water = new float[N][N];
  energy = new float[N][N];
  for(int i = 0; i < N; i++)
  for(int j = 0; j < N; j++)
  {
    water[i][j] = 0;
    energy[i][j] = 0;
  }
  
  // Initialize water levels placing a square prism of water of base length L and height H on the center of the terrain
  int L = 10;
  int H = 30;
  for(int i = N/2 -L/2; i < N/2 + L/2; i++)
  for(int j = N/2 -L/2; j < N/2 + L/2; j++)
    water[i][j] = H;
  
  // Initialize gif maker
  gif = new GifMaker(this, "export.gif");
  gif.setRepeat(0);   // make it an "endless" animation
  gif.setQuality(20); // set a higher compression quality (the default is 10) to preserve the blocks' colors
}

void draw()
{
  // Clear the canvas
  background(50);
  
  // Check and increment time counter (the exported gif will contain 50 frames)
  if(t >= TWO_PI)
  {
    gif.finish();
    exit();
  }
  else
  {
    t += TWO_PI/50;
  }
  
  // Set isometric projection
  setOrtho();
  
  // Draw terrain and water
  drawTerrain();
  drawWater();
  
  // Run 10 iterations of the fluid simulation procedure
  for(int i=0; i < 10; i++) updateWater();
  
  // Add this frame to the gif maker
  gif.addFrame();
}

// This function generates the terrain
void init_terrain()
{
  terrain = new int[N][N];
  
  for(int i = 0; i < N; i++)
  for(int j = 0; j < N; j++)
  {
    // Create walls protecting the limits of the terrain
    // These walls will be invisible (the drawTerrain() procedure won't draw them)
    if(i==0||i==N-1||j==0||j==N-1)
    {
      terrain[i][j] = 100*N;
    }
    else
    {
      // H: the (i,j) height determined by a 2D parabolic equation
      // P: a random perturbation generated by perlin noise to be added to H
      float H = 0.4*N - 0.02*(pow(i-N/2,2)+pow(j-N/2,2));
      float P = 0.5*N*(-0.5 + noise(terrainNoise*i/N,terrainNoise*j/N,100));
      terrain[i][j] = max(0,int(H+P));
    }
  }
}

void updateWater()
{
  float[][] new_water = water;
  float[][] new_energy = energy;
  
  // Friction: determines fluid viscosity
  float friction = 0.125;
  
  for(int i = 0; i < N; i++)
  for(int j = 0; j < N; j++)
  {
    // Lp: left water pressure | Rp: right water pressure | Bp: back water pressure | Fp: front water pressure
    float Lp,Rp,Bp,Fp;
    Lp = Rp = Bp = Fp = 0;
    
    // Avoid border cases
    if(i > 0)    Lp = terrain[i-1][j]+water[i-1][j]+energy[i-1][j];
    if(i < N-1)  Rp = terrain[i+1][j]+water[i+1][j]-energy[i+1][j];
    if(j > 0)    Bp = terrain[i][j-1]+water[i][j-1]+energy[i][j-1];
    if(j < N-1)  Fp = terrain[i][j+1]+water[i][j+1]-energy[i][j+1];
    
    if(i > 0 && terrain[i][j]+water[i][j]-energy[i][j] > Lp)
    {
      float flow = min(water[i][j], terrain[i][j]+water[i][j]-energy[i][j] - Lp)/16;
      new_water[i-1][j]  += flow;
      new_water[i][j]    += -flow;
      new_energy[i-1][j] *= (1-friction);
      new_energy[i-1][j] += -flow;
    }
    
    if(i < N-1 && terrain[i][j]+water[i][j]+energy[i][j] > Rp)
    {
      float flow = min(water[i][j], terrain[i][j]+water[i][j]+energy[i][j] - Rp)/16;
      new_water[i+1][j]  += flow;
      new_water[i][j]    += -flow;
      new_energy[i+1][j] *= (1-friction);
      new_energy[i+1][j] += flow;
    }
    
    if(j > 0 && terrain[i][j]+water[i][j]-energy[i][j] > Bp)
    {
      float flow = min(water[i][j], terrain[i][j]+water[i][j]-energy[i][j] - Bp)/16;
      new_water[i][j-1]  += flow;
      new_water[i][j]    += -flow;
      new_energy[i][j-1] *= (1-friction);
      new_energy[i][j-1] += -flow;
    }
    
    if(j < N-1 && terrain[i][j]+water[i][j]+energy[i][j] > Fp)
    {
      float flow = min(water[i][j], terrain[i][j]+water[i][j]+energy[i][j] - Fp)/16;
      new_water[i][j+1]  += flow;
      new_water[i][j]    += -flow;
      new_energy[i][j+1] *= (1-friction);
      new_energy[i][j+1] += flow;
    }
  }
  
  water = new_water;
  energy = new_energy;
}

void setOrtho()
{
  float a = 0.7;
  ortho(-a*width,a*width,-a*height,a*height);
  rotateX(-PI/5);
  rotateY(PI/3);
}

void drawTerrain()
{
  for(int i = 1; i < N-1; i++)
  for(int j = 1; j < N-1; j++)
  for(int k = 0; k < terrain[i][j]; k++)
  {
    // Adjust color configurations as you will (this configuration generates "reddish clay" terrains)
    int hue = 10*(int(0 + 50*noise(hueNoise*i/N,hueNoise*j/N,hueNoise*k/N))/10);
    int saturation = 10*(int(50 + 100*noise(1000+saturationNoise*i/N,saturationNoise*j/N,saturationNoise*k/N))/10);
    int brightness = 150;
    
    // Drawing the edges of blocks with similar colors to their faces' colors creates an aesthetically pleasing effect
    stroke(hue,0.8*saturation,0.8*brightness);
    
    pushMatrix();
      fill(hue,saturation,brightness);
      translate(-width/2 + i*cw, 1.3*width - k*cw, -width/2 + j*cw);
      box(cw);
    popMatrix();
  }
}

void drawWater()
{
  stroke(150,200,250);
  for(int i = 0; i < N; i++)
  for(int j = 0; j < N; j++)
  {    
    for(int k = terrain[i][j]; k < terrain[i][j]+int(round(water[i][j])); k++)
    {
      pushMatrix();
        fill(150,200,200);
        translate(-width/2 + i*cw, 1.3*width - k*cw, -width/2 + j*cw);
        box(cw);
      popMatrix();
    }
  }
}
